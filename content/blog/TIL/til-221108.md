---
title: TIL 221108
date: 2022-11-08 00:11:21
category: til
thumbnail: { thumbnailSrc }
draft: true
---

### Memory Heap 용량 초과 이슈

Node.js application에서 Out of Memory 이슈가 발생했다.

> 기초 지식 : Node.js의 Memory ?

Node.js는 JavaScript의 런타임(환경)이다. JavaScript는 웹 브라우저에서만 실행되도록 만들어진 스크립트 언어였기 때문에 브라우저에서 벗어나서 이를 독립적으로 실행시킬 수 있는 환경이 필요했다. Node.js는 브라우저에서도 사용되는 V8 엔진 위에서 돌아가며 V8 엔진이 JavaScript 코드를 기계가 이해할 수 있는 native 언어로 컴파일 시켜주는 역할을 한다.

### nvm use 16

### .zshrc 에서 하는 일

vercel 또는 vc 명령어가 바로 먹히지 않았던 이유

- shell : os에 명령어를 전달할 수 있음

### 요구사항이 변하더라도 코드의 변화를 최소한으로. (09)

Component에서 보여줘야할 데이터의 형태가 변해야할 때, 어떤 것들을 변경하는게 코드의 직접 변화를 줄일 수 있을까?

예를 들어, 유저의 입력 값을 그대로 보여주는게 아니라 특정 변형이 필요하다면 string을 조작하는 로직에 dependency가 있을 수 밖에 없다. 처음 구현할 당시에는 입력값 모두 대문자로 바꿔줘야한다는 요구 사항이 있었고 시간이 흘러 입력값 앞, 뒤에 공백이 있다면 모두 삭제해야한다는 요구사항이 추가된 경우를 생각해보자!

아래는 input으로 값을 입력받고 Submit 버튼을 눌렀을 때 변경된 값을 출력해주는 Form 컴포넌트이다. props로 받는 transformName 함수로 input 을 변경시킨다.

```ts
const Form = ({
  transformName,
}: {
  transformName: (name: string) => string
}) => {
  const [name, setName] = useState('')
  const handleSubmit = () => {
    const transformedName = transformName(name)
    alert(transformedName)
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type="text" onChange={e => setName(e.target.value)} value={name} />
      <button type="submit">Submit</button>
    </form>
  )
}
```

App 컴포넌트에서 Form 컴포넌트에 필요한 transformName 함수를 정의해줬다.

```ts
const App = () => {
  const upperCase = (name: string) => name.toUpperCase()

  return <Form transformName={upperCase} />
}
```

여기서 문자열의 앞,뒤의 공백이 있을 때 이를 삭제하는 로직도 추가된다고 가정해보자. 코드의 변경은 최소화하면서 요구 사항을 만족시킬 수 있는 방법은 뭐가 있을까?

먼저 가장 쉽게 떠올릴 수 있는 방법을 생각해보면 아래와 같이 transformName 함수를 수정하는 것일거다.

```ts
const App = () => {
  const transformName = name => {
    const a = name.toUpperCase()
    const b = a.trim()
    return b
  }

  return <Form transformName={transformName} />
}
```

하지만 이 것은 transformName 이란 함수의 구현을 직접 바꿔버린 형태이다. 만약에 점점 요구 사항이 늘어날 때도 이렇게 변경한다면 어떻게 될까? 유저의 권한에 따라 결과값이 달라져야한다고 했을 때를 생각해보자. canEdit이란 값에 의존하게 되기 때문에 transformName에 인자를 추가해줘야 한다.

```ts
const App = () => {
  const canEdit = useCanEdit() // 유저가 edit 권한이 있는지 없는지 체크하는 hook
  const transformName = (name, canEdit) => {
    const a = name.toUpperCase()
    const b = a.trim()
    if (canEdit) {
      return `${b} created by editor`
    }
    return b
  }

  return <Form transformName={transformName} canEdit={canEdit} />
}
```

transformName의 인자가 하나 추가 되었기 때문에 Form 컴포넌트의 props type과 handleSubmit 또한 변경해줘야한다.
요구 사항이 추가되니 여러 곳에서 변경이 발생했다.

```ts
const App = () => {
  const upperCase = name => name.toUpperCase()
  const trimWhiteSpace = name => name.trim()
  const addCreatedBy = name => `${name} created by editor`

  const transformName = name => {
    const a = name.toUpperCase()
    const b = a.trim()
    return b
  }

  const transformFactory = (transformers: ((name: string) => name)[]) => {
    return name =>
      transformers.reduce((value, transformer) => transformer(value), name)
  }

  return (
    <Form
      transformName={
        canEdit
          ? [upperCase, trimWhiteSpace, addCreatedBy]
          : [upperCase, trimWhiteSpace]
      }
      canEdit={canEdit}
    />
  )
}
```

- import로 helper에 대한 dependency를 가지는 것과 컴포넌트에서 helper를 주입받는건 어떤 차이가 있을까? 컴포넌트가 사용될 때 명시적으로 interface에 해당 helper에 대한 의존성이 있다는 걸 알 수 있으니 독립적으로 해당 컴포넌트를 분리해서 다른 곳에서도 사용해야 한다면 props로 받아서 사용할 수 도 있겠다.
